#!/usr/bin/env node

const config = require("./config");
const chalk = require("chalk");
const axios = require("axios");
const { API_URLS } = require("./const");
require("dotenv").config({ path: config.envPath });

const SLAVE_IP = process.env.K8S_SLAVE;

console.log(chalk.blue(`ðŸ“ƒ Deleting all services running on ${SLAVE_IP}`));

(async () => {
  await deleteAllServices();
})();

async function deleteAllServices() {
  // delete all connectors
  const connectorResponse = await axios.get(API_URLS.CONNECTOR);
  await Promise.all(
    connectorResponse.data.map(async ({ group, name }) => {
      await axios.put(`${API_URLS.CONNECTOR}/${name}/stop?group=${group}`);
      await axios.delete(`${API_URLS.CONNECTOR}/${name}?group=${group}`);
    })
  );

  const streamResponse = await axios.get(API_URLS.STREAM);
  await Promise.all(
    streamResponse.data.map(async ({ group, name }) => {
      await axios.put(`${API_URLS.STREAM}/${name}/stop?group=${group}`);
      await axios.delete(`${API_URLS.STREAM}/${name}?group=${group}`);
    })
  );

  const shabondiResponse = await axios.get(API_URLS.SHABONDI);
  await Promise.all(
    shabondiResponse.data.map(async ({ group, name }) => {
      await axios.put(`${API_URLS.SHABONDI}/${name}/stop?group=${group}`);
      await axios.delete(`${API_URLS.SHABONDI}/${name}?group=${group}`);
    })
  );

  const topicResponse = await axios.get(API_URLS.TOPIC);
  await Promise.all(
    topicResponse.data.map(async ({ group, name }) => {
      await axios.put(`${API_URLS.TOPIC}/${name}/stop?group=${group}`);
      await axios.delete(`${API_URLS.TOPIC}/${name}?group=${group}`);
    })
  );

  const workerResponse = await axios.get(API_URLS.WORKER);
  await Promise.all(
    workerResponse.data.map(async ({ group, name }) => {
      await axios.put(`${API_URLS.WORKER}/${name}/stop?group=${group}`);
      await axios.delete(`${API_URLS.WORKER}/${name}?group=${group}`);
    })
  );

  const brokerResponse = await axios.get(API_URLS.BROKER);
  await Promise.all(
    brokerResponse.data.map(async ({ group, name }) => {
      await axios.put(`${API_URLS.BROKER}/${name}/stop?group=${group}`);
      await axios.delete(`${API_URLS.BROKER}/${name}?group=${group}`);
    })
  );

  const zookeeperResponse = await axios.get(API_URLS.ZOOKEEPER);
  await Promise.all(
    zookeeperResponse.data.map(async ({ group, name }) => {
      await axios.put(`${API_URLS.ZOOKEEPER}/${name}/stop?group=${group}`);
      await axios.delete(`${API_URLS.ZOOKEEPER}/${name}?group=${group}`);
    })
  );

  const pipelineResponse = await axios.get(API_URLS.PIPELINE);
  await Promise.all(
    pipelineResponse.data.map(async ({ group, name }) => {
      await axios.delete(`${API_URLS.PIPELINE}/${name}?group=${group}`);
    })
  );

  const nodeResponse = await axios.get(API_URLS.NODE);
  await Promise.all(
    nodeResponse.data.map(async ({ hostname }) => {
      await axios.delete(`${API_URLS.NODE}/${hostname}`);
    })
  );

  const objectResponse = await axios.get(API_URLS.OBJECT);
  await Promise.all(
    objectResponse.data.map(async ({ group, name }) => {
      await axios.delete(`${API_URLS.OBJECT}/${name}?group=${group}`);
    })
  );
}

// async function waitUntil(retryUrl, checkBreakCondition) {
//   const maxRetry = 5;
//   let retryCount = 0;
//   const sleepTime = 2000;

//   while (retryCount < maxRetry) {
//     try {
//       const response = await retryUrl();
//       if (checkBreakCondition(response)) return response;
//     } catch (error) {
//       console.log("retry API failed but we will continue to execute: ", error);
//     }

//     await sleep(sleepTime);
//     retryCount++;
//   }
// }

// function isStopped(response) {
//   return typeof response.data.state === "undefined";
// }

// const waitForRunning = (res) => res.data.state === SERVICE_STATE.RUNNING;

// const waitForClassInfosReady = (res) => !isEmpty(res.data.classInfos);

// const waitForTopicReady = (res) => res.data.state === SERVICE_STATE.RUNNING;

// const wait = async ({
//   api,
//   objectKey,
//   checkFn,
//   checkParam,
//   maxRetry = 10,
//   sleep = 2000,
// }: {
//   api: API,
//   objectKey,
//   checkFn: (res, params) => boolean,
//   checkParam?: object,
//   maxRetry?: number,
//   sleep?: number,
// }) => {
//   let retryCount = 0;
//   while (retryCount < maxRetry) {
//     try {
//       const res =
//         (await api.get) <
//         T >
//         {
//           name: objectKey.name,
//           queryParams: { group: objectKey.group },
//         };
//       if (checkFn(res, checkParam)) {
//         return res;
//       }
//     } catch (error) {
//       //Something went wrong, but we still retry until exceed maxRetry
//       // eslint-disable-next-line no-console
//       console.log("retry API failed but we will continue to execute: ", error);
//     }

//     await commonUtils.sleep(sleep);
//     retryCount++;
//   }
//   const errorRes: BasicResponse = {
//     data: {
//       error: {
//         code: "N/A",
//         message: "exceed max retry",
//         stack: "",
//       },
//     },
//     status: -1,
//     title: "WaitApi Failed.",
//   };
//   throw errorRes;
// };
